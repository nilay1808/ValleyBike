# -*- coding: utf-8 -*-
"""Optimal_Bike_Allocation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dsSD8-Yq9r7cjYGBqnAFsf86QUXmWqCp
"""

import csv
import random
from scipy.stats import poisson
import numpy as np
from itertools import permutations
import itertools
import torch
import time
from collections import defaultdict
import json

from google.colab import drive
drive.mount('/content/drive')
folder = '/content/drive/Shared drives/Math 456/ValleyBike Data/'
indexToLoc = {}
locToIndex = {}
locations = []
station_capacity = []
with open(folder + 'capacity.csv') as csv_file:
  csv_reader = csv.reader(csv_file,delimiter=',')
  line_count = 0
  for row in csv_reader:
    indexToLoc[line_count] = row[0]
    locToIndex[row[0]] = line_count
    locations.append(row[0])
    station_capacity.append(int(row[1]))
    line_count +=1
print("Number of Locations:",line_count)

# poisson.pmf(0,0.75) stockout number as 1st para and rate as second para

# Parameters takes in list of potential -1 or 1 configuration and an initial number of bikes
# Returns list of stockouts indexed by each permuatation 
def findStockouts(arr, initial_bikes, capacity):
  current_number = initial_bikes
  stockout_list = []
  for i in range(len(arr)):
    stockout = 0
    current_number = initial_bikes
    for j in range(len(arr[i])):
      
      if current_number+arr[i][j]<0 or current_number+arr[i][j]>capacity:
        stockout+=1
      else:
        current_number+=arr[i][j]
    stockout_list.append(stockout)
  return torch.FloatTensor(stockout_list)

failedLoc = []
rates = [0.5]*57

# Arguments 
day = 'Monday'
weekNum = '0'
month = 'August'


with open(folder+'test.txt') as json_file:
  data = json.load(json_file)
  for place in locations:
    try:
      rates[locToIndex[place]] = float(data[place][month][weekNum][day]['dock'])
    except:
      failedLoc.append(place)

print('Locations not available',failedLoc)
# print(rates)

# Generates random docking rates
# rates = np.random.uniform(size=57)
# rates = list(rates)

x=[-1,1]

# Generates the possibilities of docking or removal 
arr = [p for p in itertools.product(x, repeat=10)]


# This variable gives the number of 1's in each permutations size of 32768
numOfDocking = []
for perm in arr:
  count =0
  for i in perm:
    if i==1:
      count+=1
  numOfDocking.append(count)
numOfDocking = torch.FloatTensor(numOfDocking)

arr = torch.FloatTensor(arr)

# Creates the average docking at each station
avg_docking_rate = [a*b for a,b in zip(station_capacity,rates)]

calculations =[] #This holds the calculations from poisson from every station at every permuatation
print("==============Starting heavy calculations=========")
start_time = time.time()
for i in range(len(locations)):
  toAdd= []
  if i%5==0:
    print("Percent Calculated:",i/len(locations)*100 )
  for j in range(len(arr)):
    toAdd.append(poisson.pmf(numOfDocking[j],avg_docking_rate[i]))
  calculations.append(toAdd)
print("Time taken:", time.time()-start_time)
calculations= torch.FloatTensor(calculations)
# calculations.size()

allocation_bikes = [2]*57
start_time =time.time()
findStockouts(arr,allocation_bikes[0],station_capacity[0])
end_time = time.time()-start_time
print("Time taken for one stockout", end_time)
# print("Estimated time to complete the program with Approach 1:",end_time*57*57*300)
total_capacity = sum(station_capacity)
numOfBikes=min(500,total_capacity-114)-114

dynamic = defaultdict()
for n in range(len(locations)):
  dynamic[n] = defaultdict()


loss=0
max_weight = 0
max_indexLoc = 0
prevLoss = 1000000


print(numOfBikes)
while numOfBikes>0:
  check = False
  max_weight = 0
  max_indexLoc = 0
  loss=0
  sum_weighted_averages=0
  weight_averages = []
  for i in range(len(locations)):

    if station_capacity[i] in dynamic[allocation_bikes[i]] != None:
      stockouts = dynamic[allocation_bikes[i]][station_capacity[i]]
    else:
      stockouts = findStockouts(arr,allocation_bikes[i],station_capacity[i])
      dynamic[allocation_bikes[i]][station_capacity[i]] = stockouts

    sum_weighted_averages += calculations[i].dot(stockouts)
    weight_averages.append(calculations[i].dot(stockouts))
  addOneArray = []
  for i in range(len(locations)):
    if station_capacity[i] in dynamic[allocation_bikes[i]+1] != None:
      stockouts = dynamic[allocation_bikes[i]+1][station_capacity[i]]
    else:
      stockouts = findStockouts(arr,allocation_bikes[i]+1,station_capacity[i])
      dynamic[allocation_bikes[i]+1][station_capacity[i]] = stockouts
    addOneArray.append(weight_averages[i]-calculations[i].dot(stockouts))
  max_indexLoc = addOneArray.index(max(addOneArray))

  for x in addOneArray:
    if x > 0:
      check = True
      break
      
  if check == False:
    break

  prevLoss = sum_weighted_averages
  number_check = 0

  while allocation_bikes[max_indexLoc] == station_capacity[max_indexLoc]-2:
    addOneArray[max_indexLoc]=0
    max_indexLoc = addOneArray.index(max(addOneArray))
    
    number_check+=1
    if number_check>=len(addOneArray):
      check= False
      break
    if allocation_bikes[max_indexLoc] < station_capacity[max_indexLoc]-2:
      break
  if check==False:
    break  
  
  allocation_bikes[max_indexLoc]+=1
  
  numOfBikes = numOfBikes-1

  if numOfBikes%50==0:
    print("Bikes left to allocate:", numOfBikes, "| Current Loss:",prevLoss)
print("Final loss:",prevLoss)
print("Final Allocation", allocation_bikes)
print("Number of Bikes left",numOfBikes)

print(total_capacity)

# FINAL ALLOCATION PRINTS
print('=========FINAL ALLOCATION LISTS=========')
for n in range(len(locations)):
  print(indexToLoc[n],allocation_bikes[n])

